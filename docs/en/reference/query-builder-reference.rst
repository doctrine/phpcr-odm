Query Builder Reference
=======================

.. note::

    This document is generated by the PHPCR-ODM from the API, if you wish to contribute a fix please either
    create an issue or make a pull request on the phpcr-odm repository.

    All the classes here documented can be found in the namespace: ``Doctrine\ODM\PHPCR\Query\Builder``

.. Run bin/phpcr-odm doctrine:phpcr:qb:dump-reference to re-generate
Reference
---------

.. _qbref_node_constraintandx:

Node: ConstraintAndx
~~~~~~~~~~~~~~~~~~~~

Contraint which evaluates to true when
all its child constraints evaluate to true.

If only a single constraint is appended, the appended
constraint will behave as if it were not preceded by
the ConstraintAndX.

**Type**: :ref:`constraint <qbref_type_constraint>`

**Extends**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..*** :ref:`constraint <qbref_type_constraint>`


.. _qbref_node_constraintcomparison:

Node: ConstraintComparison
~~~~~~~~~~~~~~~~~~~~~~~~~~

Constraint which evaluates to true if the dynamic child
operand and the static child operand evaluate to true when operated
upon by the given operator.

The ConstraintFactory will specify the corresponding operator
for each of "eq", "gte", "gt", "lte", "lt", "like", etc.

A dynamic operand is an operand whose value is derived from the
persisted object set.

A static operand is a non-changing value, either a literal or a bound
property.

Comparisons can only be made one dynamic and one static operand. When
comparing the values between joined tables you will need to use
the JoinConditionFactory.

**Type**: :ref:`constraint <qbref_type_constraint>`

**Extends**: :ref:`OperandFactory <qbref_node_operandfactory>`

**Inherited methods**: :ref:`parameter <qbref_method_operandfactory_parameter>`, :ref:`literal <qbref_method_operandfactory_literal>`, :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`
    * **1..1** :ref:`operand_static <qbref_type_operand_static>`


.. _qbref_node_constraintfactory:

Node: ConstraintFactory
~~~~~~~~~~~~~~~~~~~~~~~

This factory node provides both leaf and factory nodes all of which
return nodes of type "constraint".

**Type**: :ref:`constraint_factory <qbref_type_constraint_factory>`

**Child Cardinality**:
    * **1..1** :ref:`constraint <qbref_type_constraint>`


.. _qbref_method_constraintfactory_andx:

->andX
^^^^^^

And composite constraint::

    $qb->where()
      ->andX()
        ->fieldIsset('f.foo')
        ->gt()->field('f.max')->literal(40)->end()
      ->end()
    ->end();


The andX node allows you to add 1, 2 or many operand nodes. When
one operand is added the "and" is removed, when more than one
is added the "and" operands are nested::

    // when adding only a single operand,
    $qb->where()->andX()->eq()->field('f.foo')->literal('bar');
    // is equivilent to:
    $qb->where()->eq()->field('f.foo')->literal('bar');


    // when adding more than one,
    $qb->where()
      ->andX()
        ->fieldIsset('f.foo')
        ->gt()->field('f.max')->literal(40)->end()
        ->eq()->field('f.zar')->literal('bar')->end()
      ->end()
    ->end();

    // is equivilent to:
    $qb->where()
      ->andX()
        ->fieldIsset('f.foo')
        ->andX()
          ->gt()->field('f.max')->literal(40)->end()
          ->eq()->field('f.zar')->litreal('bar')->end()
        ->end()
      ->end()
    ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintAndx)

**Returns**: :ref:`ConstraintAndx <qbref_node_constraintandx>`

.. _qbref_method_constraintfactory_orx:

->orX
^^^^^

Or composite constraint::

    $qb->where()
      ->orX()
        ->fieldIsset('sel_1.prop_1')
        ->fieldIsset('sel_1.prop_2')
      ->end()
    ->end();


As with "andX", "orX" allows one to many operands.

**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintOrx)

**Returns**: :ref:`ConstraintOrx <qbref_node_constraintorx>`

.. _qbref_method_constraintfactory_fieldisset:

->fieldIsset
^^^^^^^^^^^^

Field existance constraint::

    $qb->where()->fieldIsset('sel_1.prop_1')->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintFieldIsset)

**Returns**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Arguments**:

* **$field**: *string* - Field to check

.. _qbref_method_constraintfactory_fulltextsearch:

->fullTextSearch
^^^^^^^^^^^^^^^^

Full text search constraint::

    $qb->where()->fullTextSearch('sel_1.prop_1', 'search_expression')->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintFullTextSearch)

**Returns**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Arguments**:

* **$field**: *string* - Name of field to check, including alias name.
* **$fullTextSearchExpression**: *string* - Search expression.

.. _qbref_method_constraintfactory_same:

->same
^^^^^^

Same document constraint::

    $qb->where()->same('/path/to/doc', 'sel_1')->end();


Relates to PHPCR QOM SameNodeInterface.

**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintSame)

**Returns**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Arguments**:

* **$path**: *string* - Path to reference document.
* **$alias**: *string* - Name of alias to use.

.. _qbref_method_constraintfactory_descendant:

->descendant
^^^^^^^^^^^^

Descendant document constraint::

      $qb->where()->descendant('/ancestor/path', 'sel_1')->end();


Relates to PHPCR QOM DescendantNodeInterface

**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintDescendant)

**Returns**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Arguments**:

* **$ancestorPath**: *string* - Select descendants of this path.
* **$alias**: *string* - Name of alias to use.

.. _qbref_method_constraintfactory_child:

->child
^^^^^^^

Select children of the aliased document at the given path::

    $qb->where()->child('/parent/path', 'sel_1')->end();


Relates to PHPCR QOM ChildNodeInterface.

**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintChild)

**Returns**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Arguments**:

* **$parentPath**: *string* - Select children of this path.
* **$alias**: *string* - Name of alias to use

.. _qbref_method_constraintfactory_eq:

->eq
^^^^

Equality comparison constraint::

    $qb->where()
      ->eq()
        ->field('sel_1.foobar')
        ->literal('var_1')
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_neq:

->neq
^^^^^

Inequality comparison constraint::

    $qb->where()
      ->neq()
        ->field('sel_1.foobar')
        ->literal('var_1')
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_lt:

->lt
^^^^

Less than comparison constraint::

    $qb->where()
      ->lt()
        ->field('sel_1.foobar')
        ->literal(5)
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_lte:

->lte
^^^^^

Less than or equal to comparison constraint::

    $qb->where()
      ->lte()
        ->field('sel_1.foobar')
        ->literal(5)
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_gt:

->gt
^^^^

Greater than comparison constraint::

    $qb->where()
      ->gt()
        ->field('sel_1.foobar')
        ->literal(5)
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_gte:

->gte
^^^^^

Greater than or equal to comparison constraint::

    $qb->where()
      ->gte()
        ->field('sel_1.foobar')
        ->literal(5)
      ->end();


**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_method_constraintfactory_like:

->like
^^^^^^

Like comparison constraint.

Use "%" as wildcards::

    $qb->where()
      ->like()
        ->field('sel_1.foobar')
        ->literal('foo%')
      ->end();


The above example will match "foo" and "foobar" but not "barfoo".

**Adds**: :ref:`constraint <qbref_node_constraint>` (ConstraintComparison)

**Returns**: :ref:`ConstraintComparison <qbref_node_constraintcomparison>`

.. _qbref_node_constraintnot:

Node: ConstraintNot
~~~~~~~~~~~~~~~~~~~

Constraint which evaluates to the opposite truth of its child
operand.

**Type**: :ref:`constraint <qbref_type_constraint>`

**Extends**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..1** :ref:`constraint <qbref_type_constraint>`


.. _qbref_node_constraintorx:

Node: ConstraintOrx
~~~~~~~~~~~~~~~~~~~

Constraint which evaluates to true if any one of its children
evaluates to true.

Like the ConstraintAndx constraint a single child will act as if
it were not preceded with a ConstraintOrx.

**Type**: :ref:`constraint <qbref_type_constraint>`

**Extends**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..*** :ref:`constraint <qbref_type_constraint>`


.. _qbref_node_from:

Node: From
~~~~~~~~~~

The From node specifies the document source (or sources in the
case of a join).

**Type**: :ref:`from <qbref_type_from>`

**Child Cardinality**:
    * **1..1** :ref:`source <qbref_type_source>`


.. _qbref_node_operanddynamicfactory:

Node: OperandDynamicFactory
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Factory node for dynamic operands.

**Type**: :ref:`operand_dynamic_factory <qbref_type_operand_dynamic_factory>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`


.. _qbref_method_operanddynamicfactory_fulltextsearchscore:

->fullTextSearchScore
^^^^^^^^^^^^^^^^^^^^^

Represents the aliased documents rank by relevance to the full text
search expression given by the "fullTextSearch" constraint::

    $qb->where()
      ->gt()
        ->fullTextSearchScore('sel_1')
        ->literal(50)
      ->end()
    ->end();

    $qb->orderBy()
      ->asc()->fullTextSearchScore('sel_1')
    ->end();


See also: http://www.day.com/specs/jcr/2.0/6_Query.html#FullTextSearchScore

**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicFullTextSearchScore)

**Returns**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Arguments**:

* **$alias**: *string* - Name of alias to use

.. _qbref_method_operanddynamicfactory_length:

->length
^^^^^^^^

Length operand resolves to length of aliased document::

    $qb->where()
      ->gt()
        ->length('alias_1.prop_1')
        ->literal(50)
      ->end()
    ->end();

    $qb->orderBy()->asc()->fullTextSearchScore('sel_1')->end();


**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicLength)

**Returns**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Arguments**:

* **$field**: *string* - Name of field to check.

.. _qbref_method_operanddynamicfactory_lowercase:

->lowerCase
^^^^^^^^^^^

LowerCase operand evaluates to lower-cased string of child operand::

    $qb->where()
      ->eq()
        ->lowerCase()->field('sel_1.prop_1')->end()
        ->literal('lower_case')
      ->end()
    ->end();


**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicLowerCase)

**Returns**: :ref:`OperandDynamicLowerCase <qbref_node_operanddynamiclowercase>`

.. _qbref_method_operanddynamicfactory_uppercase:

->upperCase
^^^^^^^^^^^

UpperCase operand evaluates to upper-cased string of child operand::

    $qb->where()
      ->eq()
          ->upperCase()->field('sel_1.prop_1')->end()
          ->literal('UPPER_CASE')
      ->end()
    ->end();


**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicUpperCase)

**Returns**: :ref:`OperandDynamicUpperCase <qbref_node_operanddynamicuppercase>`

.. _qbref_method_operanddynamicfactory_localname:

->localName
^^^^^^^^^^^

Document local name evaluates to the local (non namespaced)
name of the node being compared.

For example, if a node has the path "/path/to/foobar", then "foobar"
is the local node name::

    $qb->where()
      ->eq()
        ->localName('sel_1')
        ->literal('my_node_name')
      ->end()
    ->end();


Relates to PHPCR NodeLocalNameInterface

**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicLocalName)

**Returns**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Arguments**:

* **$alias**: *string* - Name of alias to use

.. _qbref_method_operanddynamicfactory_name:

->name
^^^^^^

Evaluates to the namespaced name of the node being compared.

For example, if a node has the path "/path/to/bar:foobar", then
"bar:foobar" is the namespaced node name::

    $qb->where()
      ->eq()
        ->name('sel_1')
        ->literal('namespace:my_node_name')
      ->end()
    ->end();


Relates to PHPCR NodeNameInterface.

**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicName)

**Returns**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Arguments**:

* **$alias**: *string* - Name of alias to use

.. _qbref_method_operanddynamicfactory_field:

->field
^^^^^^^

Evaluates to the value of the specified field::

    $qb->where()
      ->eq()
        ->field('sel_1.prop_name')
        ->literal('my_field_value')
      ->end()
    ->end();


**Adds**: :ref:`operand_dynamic <qbref_node_operand_dynamic>` (OperandDynamicField)

**Returns**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Arguments**:

* **$field**: *string* - name of field to check, including alias name.

.. _qbref_node_operanddynamiclowercase:

Node: OperandDynamicLowerCase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dynamic operand which evaluates to the lowercased value of the child operand.

**Type**: :ref:`operand_dynamic <qbref_type_operand_dynamic>`

**Extends**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Inherited methods**: :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`


.. _qbref_node_operanddynamicuppercase:

Node: OperandDynamicUpperCase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Operand which evaluates to the upper case version of its child operand.

**Type**: :ref:`operand_dynamic <qbref_type_operand_dynamic>`

**Extends**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Inherited methods**: :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`


.. _qbref_node_operandfactory:

Node: OperandFactory
~~~~~~~~~~~~~~~~~~~~

Factory node for all operands, both dynamic and static.

**Type**: :ref:`operand_dynamic_factory <qbref_type_operand_dynamic_factory>`

**Extends**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Inherited methods**: :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`


.. _qbref_method_operandfactory_parameter:

->parameter
^^^^^^^^^^^

Evaluates to the value of the parameter bound to the given $name.

Relates to PHPCR BindVariableValueInterface::

    $qb->where()->eq()->field('f.foobar')->parameter('param_1')->end();
    $qb->setParameter('param_1', 'foo');


**Adds**: :ref:`operand_static <qbref_node_operand_static>` (OperandStaticParameter)

**Returns**: :ref:`OperandFactory <qbref_node_operandfactory>`

**Arguments**:

* **$name**: *string* - Name of parameter to resolve.

.. _qbref_method_operandfactory_literal:

->literal
^^^^^^^^^

Evaluates to the given literal value::

    $qb->where()->eq()->field('f.foobar')->literal('Literal Value')->end();


**Adds**: :ref:`operand_static <qbref_node_operand_static>` (OperandStaticLiteral)

**Returns**: :ref:`OperandStaticLiteral <qbref_node_operandstaticliteral>`

**Arguments**:

* **$value**: *string* - Literal value.

.. _qbref_node_operandstaticfactory:

Node: OperandStaticFactory
~~~~~~~~~~~~~~~~~~~~~~~~~~

Factory node for static operands.

Note that this class is not used by the query builder and
is only featured here to help with tests.

**Type**: :ref:`operand_static_factory <qbref_type_operand_static_factory>`

**Extends**: :ref:`OperandFactory <qbref_node_operandfactory>`

**Inherited methods**: :ref:`parameter <qbref_method_operandfactory_parameter>`, :ref:`literal <qbref_method_operandfactory_literal>`, :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_static <qbref_type_operand_static>`


.. _qbref_node_orderby:

Node: OrderBy
~~~~~~~~~~~~~

Factory node for order by.

Query results can be ordered by any dynamic operand
in either ascending or descending order.

**Type**: :ref:`order_by <qbref_type_order_by>`

**Child Cardinality**:
    * **0..*** :ref:`ordering <qbref_type_ordering>`


.. _qbref_method_orderby_asc:

->asc
^^^^^

Add ascending ordering::

    $qb->orderBy()->asc()->field('sel_1.prop_1')->end();


**Adds**: :ref:`ordering <qbref_node_ordering>` (Ordering)

**Returns**: :ref:`Ordering <qbref_node_ordering>`

.. _qbref_method_orderby_desc:

->desc
^^^^^^

Add descending ordering::

    $qb->orderBy()->desc()->field('sel_1.prop_1')->end();


**Adds**: :ref:`ordering <qbref_node_ordering>` (Ordering)

**Returns**: :ref:`Ordering <qbref_node_ordering>`

.. _qbref_node_orderbyadd:

Node: OrderByAdd
~~~~~~~~~~~~~~~~

Node for adding an additional order by.

**Type**: :ref:`order_by <qbref_type_order_by>`

**Extends**: :ref:`OrderBy <qbref_node_orderby>`

**Inherited methods**: :ref:`asc <qbref_method_orderby_asc>`, :ref:`desc <qbref_method_orderby_desc>`

**Child Cardinality**:
    * **0..*** :ref:`ordering <qbref_type_ordering>`


.. _qbref_node_ordering:

Node: Ordering
~~~~~~~~~~~~~~

**Type**: :ref:`ordering <qbref_type_ordering>`

**Extends**: :ref:`OperandDynamicFactory <qbref_node_operanddynamicfactory>`

**Inherited methods**: :ref:`fullTextSearchScore <qbref_method_operanddynamicfactory_fulltextsearchscore>`, :ref:`length <qbref_method_operanddynamicfactory_length>`, :ref:`lowerCase <qbref_method_operanddynamicfactory_lowercase>`, :ref:`upperCase <qbref_method_operanddynamicfactory_uppercase>`, :ref:`localName <qbref_method_operanddynamicfactory_localname>`, :ref:`name <qbref_method_operanddynamicfactory_name>`, :ref:`field <qbref_method_operanddynamicfactory_field>`

**Child Cardinality**:
    * **1..1** :ref:`operand_dynamic <qbref_type_operand_dynamic>`


.. _qbref_node_querybuilder:

Node: QueryBuilder
~~~~~~~~~~~~~~~~~~

The Query Builder root node.

This is the node which is returned when a query builder is asked for::

    $dm = // get document manager
    $qb = $dm->createQueryBuilder();
    $qb->fromDocument('Blog\Post', 'p');
    $qb->where()->eq()->field('p.title')->literal('My Post');
    $docs = $qb->getQuery()->execute();


A converter is required to be set if the purpose of the query builder
is to be fulfilled. The PHPCR converter walks over the query builder node
hierarchy and converts the object graph the PHPCR QOM object graph.

**Type**: :ref:`builder <qbref_type_builder>`

**Child Cardinality**:
    * **0..*** :ref:`select <qbref_type_select>`
    * **1..1** :ref:`from <qbref_type_from>`
    * **0..1** :ref:`where <qbref_type_where>`
    * **0..*** :ref:`order_by <qbref_type_order_by>`


.. _qbref_method_querybuilder_where:

->where
^^^^^^^

Where factory node is used to specify selection criteria::

    $qb->where()
      ->eq()
        ->field('a.foobar')->literal('bar')->end()
      ->end()
    ->end();


**Adds**: :ref:`where <qbref_node_where>` (Where)

**Returns**: :ref:`Where <qbref_node_where>`

.. _qbref_method_querybuilder_andwhere:

->andWhere
^^^^^^^^^^

Add additional selection criteria using the AND operator.

**Adds**: :ref:`where <qbref_node_where>` (WhereAnd)

**Returns**: :ref:`WhereAnd <qbref_node_whereand>`

.. _qbref_method_querybuilder_orwhere:

->orWhere
^^^^^^^^^

Add additional selection criteria using the OR operator.

**Adds**: :ref:`where <qbref_node_where>` (WhereOr)

**Returns**: :ref:`WhereOr <qbref_node_whereor>`

.. _qbref_method_querybuilder_from:

->from
^^^^^^

Set the from source for the query::

    $qb->from()->document('Foobar', 'a');

    // or with a join ...

    $qb->from('a')->joinInner()
      ->left()->document('Foobar', 'a')->end()
      ->right()->document('Barfoo', 'b')->end()
      ->condition()->equi('a.prop_1', 'b.prop_1')->end()
    ->end();


**Adds**: :ref:`from <qbref_node_from>` (From)

**Returns**: :ref:`From <qbref_node_from>`

**Arguments**:

* **$primaryAlias**: *string* - Alias to use as primary source (optional for single sources)

.. _qbref_method_querybuilder_fromdocument:

->fromDocument
^^^^^^^^^^^^^^

Shortcut for::

    $qb->from()
      ->document('Foobar', 'a')->end()
    ->end();


Which becomes::

    $qb->fromDocument('Foobar', 'a')->end();


Replaces any existing from source.

**Adds**: :ref:`from <qbref_node_from>` (From)

**Returns**: :ref:`QueryBuilder <qbref_node_querybuilder>`

**Arguments**:

* **$documentFqn**: *string* - Fully qualified class name for document.
* **$primaryAlias**: *string* - Alias for document source and primary alias when using multiple sources.

.. _qbref_method_querybuilder_addjoinleftouter:

->addJoinLeftOuter
^^^^^^^^^^^^^^^^^^

Replace the existing source with a left outer join source using the existing
source as the left operand::

    $qb->fromDocument('Foobar', 'a')
      ->addJoinLeftOuter()
        ->right()->document('Barfoo', 'b')->end()
        ->condition()->equi('a.prop_1', 'b.prop_2')->end()
      ->end()
    ->end();


Note that for outer joins to work correctly, documents being joined to must be mapped with
a node type that is unique to the repository workspace, and the ``uniqueNodeType`` property
must be set to ``true`` for the document (see :ref:`<_annref_document>`). Otherwise, the join
will behave as an inner join.

**Adds**: :ref:`select <qbref_node_select>` (Select)

**Returns**: :ref:`SourceJoin <qbref_node_sourcejoin>`

.. _qbref_method_querybuilder_addjoinrightouter:

->addJoinRightOuter
^^^^^^^^^^^^^^^^^^^

Replace the existing source with a right outer join source using the existing
source as the left operand::

    $qb->fromDocument('Foobar', 'a')
      ->addJoinRightOuter()
        ->right()->document('Barfoo', 'b')->end()->end()
        ->condition()->equi('a.prop_1', 'b.prop_2')->end()
      ->end()
    ->end();


Note that for outer joins to work correctly, documents being joined to must be mapped with
a node type that is unique to the repository workspace, and the ``uniqueNodeType`` property
must be set to ``true`` for the document (see :ref:`<_annref_document>`). Otherwise, the join
will behave as an inner join.

**Adds**: :ref:`select <qbref_node_select>` (Select)

**Returns**: :ref:`SourceJoin <qbref_node_sourcejoin>`

.. _qbref_method_querybuilder_addjoininner:

->addJoinInner
^^^^^^^^^^^^^^

Replace the existing source with an inner join source using the existing
source as the left operand::

    $qb->fromDocument('Foobar', 'a')
      ->addJoinInner()
        ->right()->document('Barfoo', 'b')->end()
        ->condition()->equi('a.prop_1', 'b.prop_2')->end()
      ->end()
    ->end();


Note that for outer joins to work correctly, documents being joined to must be mapped with
a node type that is unique to the repository workspace, and the ``uniqueNodeType`` property
must be set to ``true`` for the document (see :ref:`<_annref_document>`). Otherwise, the join
will behave as an inner join.

**Adds**: :ref:`select <qbref_node_select>` (Select)

**Returns**: :ref:`SourceJoin <qbref_node_sourcejoin>`

.. _qbref_method_querybuilder_select:

->select
^^^^^^^^

Method to add properties for selection to builder tree, replaces any
existing select.

Number of property nodes is unbounded::

    $qb->select()
      ->field('a.prop_1')
      ->field('a.prop_2')
      ->field('a.prop_3')
    ->end();


**Adds**: :ref:`select <qbref_node_select>` (Select)

**Returns**: :ref:`Select <qbref_node_select>`

.. _qbref_method_querybuilder_addselect:

->addSelect
^^^^^^^^^^^

Add additional properties to selection::

    $qb->select()
        ->field('a.prop_1')
      ->end()
      ->addSelect()
        ->field('a.prop_2')
        ->field('a.prop_3')
        ->field('a.prop_4')
      ->end();


**Adds**: :ref:`select <qbref_node_select>` (SelectAdd)

**Returns**: :ref:`SelectAdd <qbref_node_selectadd>`

.. _qbref_method_querybuilder_orderby:

->orderBy
^^^^^^^^^

Add orderings to the builder tree.

Number of orderings is unbounded::

    $qb->orderBy()
      ->asc()->field('a.prop_1')->end()
      ->desc()->field('a.prop_2')->end()
    ->end();


**Adds**: :ref:`order_by <qbref_node_order_by>` (OrderBy)

**Returns**: :ref:`OrderBy <qbref_node_orderby>`

.. _qbref_method_querybuilder_addorderby:

->addOrderBy
^^^^^^^^^^^^

Add additional orderings to the builder tree.

**Adds**: :ref:`order_by <qbref_node_order_by>` (OrderByAdd)

**Returns**: :ref:`OrderByAdd <qbref_node_orderbyadd>`

.. _qbref_node_select:

Node: Select
~~~~~~~~~~~~

Factory node for adding selection fields.

**Type**: :ref:`select <qbref_type_select>`

**Child Cardinality**:
    * **0..*** :ref:`property <qbref_type_property>`


.. _qbref_node_selectadd:

Node: SelectAdd
~~~~~~~~~~~~~~~

Factory node for adding additional selection fields.

**Type**: :ref:`select <qbref_type_select>`

**Extends**: :ref:`Select <qbref_node_select>`

**Child Cardinality**:
    * **0..*** :ref:`property <qbref_type_property>`


.. _qbref_node_sourcejoin:

Node: SourceJoin
~~~~~~~~~~~~~~~~

**Type**: :ref:`source <qbref_type_source>`

**Child Cardinality**:
    * **1..1** :ref:`source_join_condition_factory <qbref_type_source_join_condition_factory>`
    * **1..1** :ref:`source_join_left <qbref_type_source_join_left>`
    * **1..1** :ref:`source_join_right <qbref_type_source_join_right>`


.. _qbref_node_sourcejoinconditionfactory:

Node: SourceJoinConditionFactory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Factory node for join conditions.

**Type**: :ref:`source_join_condition_factory <qbref_type_source_join_condition_factory>`

**Child Cardinality**:
    * **1..1** :ref:`source_join_condition <qbref_type_source_join_condition>`


.. _qbref_method_sourcejoinconditionfactory_descendant:

->descendant
^^^^^^^^^^^^

Descendant join condition::

      $qb->from('alias_1')
        ->joinInner()
          ->left()->document('Foo/Bar/One', 'alias_1')->end()
          ->right()->document('Foo/Bar/Two', 'alias_2')->end()
          ->condition()
            ->descendant('alias_1', 'alias_2')
          ->end()
      ->end();


**Adds**: :ref:`source_join_condition <qbref_node_source_join_condition>` (SourceJoinConditionDescendant)

**Returns**: :ref:`SourceJoinConditionFactory <qbref_node_sourcejoinconditionfactory>`

**Arguments**:

* **$descendantAlias**: *string* - Name of alias for descendant documents.
* **$ancestorAlias**: *string* - Name of alias to match for ancestor documents.

.. _qbref_method_sourcejoinconditionfactory_equi:

->equi
^^^^^^

Equi (equality) join condition::

      $qb->from('alias_1')
        ->joinInner()
          ->left()->document('Foo/Bar/One', 'alias_1')->end()
          ->right()->document('Foo/Bar/Two', 'alias_2')->end()
          ->condition()->equi('alias_1.prop_1', 'alias_2.prop_2')
        ->end()
     ->end();


See: http://en.wikipedia.org/wiki/Join_%28SQL%29#Equi-join

**Adds**: :ref:`source_join_condition <qbref_node_source_join_condition>` (SourceJoinConditionEqui)

**Returns**: :ref:`SourceJoinConditionFactory <qbref_node_sourcejoinconditionfactory>`

**Arguments**:

* **$field1**: *string* - Field name for first field.
* **$field2**: *string* - Field name for second field.

.. _qbref_method_sourcejoinconditionfactory_child:

->child
^^^^^^^

Child document join condition::

      $qb->from('alias_1')
        ->joinInner()
          ->left()->document('Foo/Bar/One', 'alias_1')->end()
          ->right()->document('Foo/Bar/Two', 'alias_2')->end()
          ->condition()->child('alias_1', 'alias_2')->end()
        ->end()
     ->end();


**Adds**: :ref:`source_join_condition <qbref_node_source_join_condition>` (SourceJoinConditionChildDocument)

**Returns**: :ref:`SourceJoinConditionFactory <qbref_node_sourcejoinconditionfactory>`

**Arguments**:

* **$childAlias**: *string* - Name of alias for child documents.
* **$parentAlias**: *string* - Name of alias to match for parent documents.

.. _qbref_method_sourcejoinconditionfactory_same:

->same
^^^^^^

Same document join condition::

      $qb->from('alias_1')
        ->joinInner()
          ->left()->document('Foo/Bar/One', 'alias_1')->end()
          ->right()->document('Foo/Bar/Two', 'alias_2')->end()
          ->condition()
            ->same('alias_1', 'alias_2', '/path_to/alias_2/document')
          ->end()
        ->end()
      ->end();


**Adds**: :ref:`source_join_condition <qbref_node_source_join_condition>` (SourceJoinConditionSameDocument)

**Returns**: :ref:`SourceJoinConditionFactory <qbref_node_sourcejoinconditionfactory>`

**Arguments**:

* **$alias1**: *string* - Name of first alias.
* **$alias2**: *string* - Name of first alias.
* **$alias2Path**: *string* - Path for documents of second alias.

.. _qbref_node_sourcejoinleft:

Node: SourceJoinLeft
~~~~~~~~~~~~~~~~~~~~

Factory node for "left" source in join.

**Type**: :ref:`source_join_left <qbref_type_source_join_left>`

**Extends**: :ref:`From <qbref_node_from>`

**Inherited methods**: :ref:`document <qbref_method_sourcefactory_document>`, :ref:`joinInner <qbref_method_sourcefactory_joininner>`, :ref:`joinLeftOuter <qbref_method_sourcefactory_joinleftouter>`, :ref:`joinRightOuter <qbref_method_sourcefactory_joinrightouter>`

**Child Cardinality**:
    * **1..1** :ref:`source <qbref_type_source>`


.. _qbref_node_sourcejoinright:

Node: SourceJoinRight
~~~~~~~~~~~~~~~~~~~~~

Factory node for "right" source in join.

**Type**: :ref:`source_join_right <qbref_type_source_join_right>`

**Extends**: :ref:`From <qbref_node_from>`

**Inherited methods**: :ref:`document <qbref_method_sourcefactory_document>`, :ref:`joinInner <qbref_method_sourcefactory_joininner>`, :ref:`joinLeftOuter <qbref_method_sourcefactory_joinleftouter>`, :ref:`joinRightOuter <qbref_method_sourcefactory_joinrightouter>`

**Child Cardinality**:
    * **1..1** :ref:`source <qbref_type_source>`


.. _qbref_node_where:

Node: Where
~~~~~~~~~~~

Factory node for where.

**Type**: :ref:`where <qbref_type_where>`

**Extends**: :ref:`ConstraintFactory <qbref_node_constraintfactory>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..1** :ref:`constraint <qbref_type_constraint>`


.. _qbref_node_whereand:

Node: WhereAnd
~~~~~~~~~~~~~~

Factory node for appending additional "wheres" with an AND

**Type**: :ref:`where <qbref_type_where>`

**Extends**: :ref:`Where <qbref_node_where>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..1** :ref:`constraint <qbref_type_constraint>`


.. _qbref_node_whereor:

Node: WhereOr
~~~~~~~~~~~~~

Factory node for appending additional "wheres" with an OR

**Type**: :ref:`where <qbref_type_where>`

**Extends**: :ref:`Where <qbref_node_where>`

**Inherited methods**: :ref:`andX <qbref_method_constraintfactory_andx>`, :ref:`orX <qbref_method_constraintfactory_orx>`, :ref:`fieldIsset <qbref_method_constraintfactory_fieldisset>`, :ref:`fullTextSearch <qbref_method_constraintfactory_fulltextsearch>`, :ref:`same <qbref_method_constraintfactory_same>`, :ref:`descendant <qbref_method_constraintfactory_descendant>`, :ref:`child <qbref_method_constraintfactory_child>`, :ref:`eq <qbref_method_constraintfactory_eq>`, :ref:`neq <qbref_method_constraintfactory_neq>`, :ref:`lt <qbref_method_constraintfactory_lt>`, :ref:`lte <qbref_method_constraintfactory_lte>`, :ref:`gt <qbref_method_constraintfactory_gt>`, :ref:`gte <qbref_method_constraintfactory_gte>`, :ref:`like <qbref_method_constraintfactory_like>`

**Child Cardinality**:
    * **1..1** :ref:`constraint <qbref_type_constraint>`


